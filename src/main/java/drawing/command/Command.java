package drawing.command;

import drawing.context.DrawingContext;

/**
 * Это базовый интерфейс для всех команд — реализация паттерна Command.
 *
 * ПОЧЕМУ SEALED INTERFACE?
 *
 * Обычный interface позволяет кому угодно создавать реализации. Sealed (Java 17+) —
 * только перечисленным классам. Это даёт мне два преимущества:
 *
 * 1) Компилятор проверяет полноту switch-выражений. Если я добавлю новую команду,
 *    но забуду обработать её где-то — код не скомпилируется. Без sealed нужен default-case.
 *
 * 2) Документация в коде: список permits показывает все возможные команды.
 *    Не нужно искать по проекту "кто реализует Command".
 *
 * ПОЧЕМУ ВСЕ КОМАНДЫ — RECORD?
 *
 * Команда — это данные запроса: "нарисуй линию от (1,1) до (5,1)".
 * Record идеально подходит:
 * - Иммутабельность: параметры не меняются после создания
 * - equals/hashCode: можно сравнивать команды в тестах
 * - Краткость: минимум boilerplate-кода
 *
 * ПАТТЕРН COMMAND — ЗАЧЕМ?
 *
 * Альтернатива — большой switch в главном цикле:
 *
 *   switch(commandType) {
 *       case "L": drawLine(...); break;
 *       case "R": drawRect(...); break;
 *       ...
 *   }
 *
 * Проблемы этого подхода:
 * - Один огромный класс со всей логикой
 * - Сложно тестировать отдельные операции
 * - Добавление команды = изменение существующего кода
 *
 * С Command-паттерном:
 * - Каждая команда — отдельный класс, легко тестируется
 * - Добавление команды = новый класс, старый код не трогаем (Open/Closed Principle)
 * - Команды можно логировать, сериализовать, откладывать выполнение
 */
public sealed interface Command permits CreateCanvasCommand, DrawLineCommand, DrawRectangleCommand, BucketFillCommand,
        QuitCommand, UndoCommand, RedoCommand, HelpCommand, SaveCommand {

    /**
     * Выполняет команду с переданным контекстом.
     *
     * Контекст содержит всё, что может понадобиться команде:
     * - Canvas для рисования
     * - Console для вывода сообщений
     * - History для undo/redo
     */
    void execute(DrawingContext context);

    /**
     * Должно ли приложение завершиться после этой команды?
     *
     * Только QuitCommand возвращает true.
     * Остальные команды используют default-реализацию (false).
     */
    default boolean shouldQuit() {
        return false;
    }

    /**
     * Изменяет ли эта команда холст?
     *
     * Это критически важно для undo/redo!
     *
     * Если команда меняет холст (DrawLine, CreateCanvas, BucketFill),
     * DrawingApp сохраняет состояние ПЕРЕД выполнением.
     *
     * Если не меняет (Help, Save, Quit, Undo, Redo),
     * сохранение не нужно и даже вредно.
     *
     * Почему Undo/Redo возвращают false, хотя меняют холст?
     * Потому что они САМИ управляют историей. Если бы DrawingApp
     * сохранял состояние перед Undo, получилась бы каша:
     * - Сохранили текущее состояние
     * - Выполнили Undo (которое само двигает по истории)
     * - Теперь в истории дубликат
     */
    default boolean modifiesCanvas() {
        return true;
    }
}
